version: 0.2

phases:
  install:
    runtime-versions:
      java: corretto17
    commands:
      - echo "Installing Docker..."
      # - yum install -y docker jq
      - apt install -y docker jq
      # Start Docker daemon
      - nohup /usr/bin/dockerd --host=unix:///var/run/docker.sock > /dev/null 2>&1 &
      - timeout 15 sh -c "until docker info; do echo waiting for docker; sleep 1; done"
  pre_build:
    commands:
      - echo "Recording pipeline start time..."
      - export PIPELINE_START_TIME=$(date +%s)
  build:
    commands:
      - echo "Building Job Management System..."
      - mkdir -p build/WEB-INF/classes
      - javac -cp "src/main/webapp/WEB-INF/lib/*" -d build/WEB-INF/classes $(find src -name "*.java")
      - cp -R src/main/resources/* build/WEB-INF/classes/
      - cp -R src/main/webapp/* build/
      - jar -cvf JobManagement.war -C build .
      - echo "WAR file built:"
      - ls -lah JobManagement.war
      - echo "Running Unit Tests..."
      - mkdir -p test_output
      - javac -cp "src/main/webapp/WEB-INF/lib/*:src" -d test_output $(find src/main/test -name "*.java")
      - java -cp "test_output:src/main/webapp/WEB-INF/lib/*" org.junit.platform.console.ConsoleLauncher --scan-class-path test_output --details summary > test_results.log 2>&1 || true
      - echo "Unit test results preview:"
      - head -n 20 test_results.log
  post_build:
    commands:
      - echo "----- POST BUILD - Starting metrics collection & deployment -----"
      # Start timer for deployment
      - export DEPLOY_START=$(date +%s)

      # Start Tomcat container in detached mode, bound to 0.0.0.0:8080
      - echo "Starting Tomcat container (accessible externally on port 8080)..."
      - docker run -d --name tomcat -p 0.0.0.0:8080:8080 tomcat:9-jdk17

      - echo "Waiting for Tomcat to initialize..."
      - sleep 15

      # Deploy WAR file
      - echo "Deploying WAR file into Tomcat container..."
      - docker cp JobManagement.war tomcat:/usr/local/tomcat/webapps/
      - echo "Waiting for deployment..."
      - sleep 20

      # Stop deployment timer
      - export DEPLOY_END=$(date +%s)
      - export DEPLOY_TIME=$((DEPLOY_END - DEPLOY_START))

      # Calculate lead time for changes = time from build start to end of deployment
      - export LEAD_TIME=$((DEPLOY_END - PIPELINE_START_TIME))

      # Record pipeline end time and calculate total pipeline time
      - export PIPELINE_END=$(date +%s)
      - export TOTAL_PIPELINE_TIME=$((PIPELINE_END - PIPELINE_START_TIME))

      # Print CI/CD Metrics Summary
      - echo "-------------------------------------------------"
      - echo String.format("| %-35s | %-15s |", "Total Pipeline Time (sec)", "$TOTAL_PIPELINE_TIME")
      - echo String.format("| %-35s | %-15s |", "Deployment Time (sec)", "$DEPLOY_TIME")
      - echo String.format("| %-35s | %-15s |", "Lead Time for Changes (sec)", "$LEAD_TIME")
      - echo String.format("| %-35s | %-15s |", "Test Summary", "$(head -n1 test_results.log || echo 'N/A')")

      # Provide access URL
      - echo ""
      - echo "Your application is now running and accessible at:"
      - echo "    http://$(curl -s http://169.254.169.254/latest/meta-data/local-ipv4):8080/JobManagement/"
      - echo ""
      - echo "When you're done testing, you can manually stop the container with:"
      - echo "    docker stop tomcat && docker rm tomcat"

      # (Optional) still collect resource/memory metrics if you like
      - docker exec tomcat vmstat -s | awk '{printf \"%.2f MB - %s\n\", \$1/1024, substr(\$0, index(\$0,\$2))}' > resource_usage_after.log
      - docker exec tomcat free -h > mem_after.log

      # (Optional) upload metrics as artifacts
      - echo "Uploading metrics logs as artifacts..."

artifacts:
  files:
    - JobManagement.war
    - test_results.log
    - metrics_summary.log
    - resource_usage_after.log
    - mem_after.log
